#### 7월 22일(목)
L-value = R-value  = x=1
- 0~9 ->10진수 ex)11,4,123,110
- 0-7 ->8진수 e)17,7,123,110  - 17=1*8^1+7*8^= 1*8+7*1=8+7=15  -앞에 0들어감
- 0-15 ->16진수  앞에 0x들어감

-정수 byte<char<short<int<long 
-실수 float <double 

자동타입변환 = 작은 크기의
비교연산자  ==  != , >  <=  , < = >=
논리 연산자 and -> 양쪽다 true 면 true  , or -> 양쪽다 false면 false
우선순위:
산술연산(단항연산자(++,--,+,-)<이항연산자(*,/,.. >비교 연산 >논리 연산
####2021 07 28(금)
- static  -정적   =여러 필드와 메서드의 오버로딩중 공통적으로 사용할떄 정정 필드,메서드를 만들어서 사용.
- (이 클래스를 기반으로 모든 인스턴스에서 공유하는 필드)
- static final a=1; ->필드 수정불가

#### 2021 0802(월)
- 객체지향언어의 특징 4가지.
- 1.캡슐화  클래스  클래스(객체),접근제한자 
( public(무제한 사용,공유) , prtected(상속:다른 패키지에 속한 자식 클래스만 공유), default(기본값,다른 패키지에서는 사용x) ,private(클래스 내부에서만 공유)-보통 클래스의 필드는 private로선언
- 2.상속  (클래스의 속성을 다른 클래스가 물려받는것  -생성자 오버라이딩 /메소드 오버라이딩 . 자식이 부모의 생성자를 호출할려면 super()
- 3.다형성( -메소드 오버로딩, 생성자 오버로딩)
- 4.추상화  : 추상클래스 . 인터페이스

- final 수정불가(필드),  클래스에다final쓰면 상속불가 , 상속가능 ,재정의 불가(메소드)

-    상속: 부모클래스 =>자식클래스
- 타입변환: 부모클래스 <=자식클래스 

byte 1   위에서 아래로 형변환은 -> 자동 타입변환        || 자식클래스   ex)Parent p = new Parent();
char 2	 아래에서 위로 -> 강제 타입변환						 Child c= new Child();
short 2												 p=c(자동 타입 변환)
int 4												 c=p(error)
long 8												 c=(Child)p
float 4
double 8                               || 부모클래스 \
-1 bit  =0/1
-1 byte= 8 bits
- 1 kb=1024 bytes
- 1mb= 1024 kb
- 1gb= 1024mb
- 1tb= 1024gb
- 1 pt= 1024tb
